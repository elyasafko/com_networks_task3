diff --git a/RUDP_API.c b/RUDP_API.c
index e5412c9..0dc9377 100644
--- a/RUDP_API.c
+++ b/RUDP_API.c
@@ -7,23 +7,39 @@
 #include <time.h>
 #include <sys/time.h>
 #include <errno.h>
+#include <stddef.h>
 
+int seq_num; // id of the expected packet
 
-int rudp_socket() 
+void rudp_dump_data(RUDP_Packet *packet)
 {
+    for (int q=0; q<offsetof(RUDP_Packet, data)+32; q+=16)
+        printf("0x%04X: %08X %08X %08X %08X\n", q,
+                *(int *)((char *)packet + q),
+                *(int *)((char *)packet + q + 4),
+                *(int *)((char *)packet + q + 8),
+                *(int *)((char *)packet + q + 12));
+}
+
+#define rudp_dump_headers(x, p) \
+    printf("%03d: " x " SYN %d ACK %d DATA %d FIN %d length %05d checksum %04X seq_num %d\n", __LINE__, p->flags.SYN, p->flags.ACK, p->flags.DATA, p->flags.FIN, p->length, p->checksum, p->seq_num)
+
+int udp_socket(const char *dest_ip, unsigned short int dest_port) 
+{
+    if (dest_ip == NULL) {
+        printf("Setting up UDP at port %u...\n", dest_port);
+    }
+    else
+    {
+        printf("Setting up UDP at %s:%u...\n", dest_ip, dest_port);
+    }
+
     int sock = socket(AF_INET, SOCK_DGRAM, 0);
     if (sock == -1) 
     {
-        perror("Error creating RUDP socket");
+        perror("Error creating UDP socket");
         return -1;
     }
-    return sock;
-}
-
-int rudp_connect(int sock, const char *dest_ip, unsigned short int dest_port)
-{
-    // Add print statements for better debugging
-    printf("Connecting to %s:%u...\n", dest_ip, dest_port);
 
     struct timeval timeout;
     timeout.tv_sec = TIMEOUT;
@@ -41,20 +57,39 @@ int rudp_connect(int sock, const char *dest_ip, unsigned short int dest_port)
     memset(&serverAddress, 0, sizeof(serverAddress)); // zero out the structure
     serverAddress.sin_family = AF_INET; // IPv4 address family
     serverAddress.sin_port = htons(dest_port); // server port
-    int rval = inet_pton(AF_INET, dest_ip, &serverAddress.sin_addr); // convert IP address to network address
-    if (rval <= 0) // if the conversion failed
+    if (dest_ip)
     {
-        perror("inet_pton() failed");
-        return -1;
-    }
+        int rval = inet_pton(AF_INET, dest_ip, &serverAddress.sin_addr); // convert IP address to network address
+        if (rval <= 0) // if the conversion failed
+        {
+            perror("inet_pton() failed");
+            return -1;
+        }
 
-    // connect to the server
-    if (connect(sock, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1)
+        // connect to the server
+        if (connect(sock, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1)
+        {
+            perror("connect failed");
+            return -1;
+        }
+    }
+    else
     {
-        perror("connect failed");
-        return -1;
+        // bind the socket to the server address
+        if (bind(sock, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1) 
+        {
+            perror("bind() failed");
+            close(sock);
+            return -1;
+        }
     }
 
+    printf("UDP socket created for %s:%u...\n\n", inet_ntoa(serverAddress.sin_addr), dest_port);
+    return sock;
+}
+
+int rudp_socket(int sock)
+{
     // send SYN message
     RUDP_Packet *packet = (RUDP_Packet *)malloc(sizeof(RUDP_Packet));
     if (packet == NULL)
@@ -64,13 +99,15 @@ int rudp_connect(int sock, const char *dest_ip, unsigned short int dest_port)
     }
     memset(packet, 0, sizeof(RUDP_Packet)); // zero out the packet
     packet->flags.SYN = 1; // set the SYN flag
+    packet->seq_num = seq_num = 0;
+    packet->checksum = checksum(packet->data, packet->length);
 
     int total_tries = 0; // total number of tries
 
     while (total_tries < RETRY) // while the total number of tries is less than the maximum number of tries
     {
-        printf("Sending SYN packet..."); // print the number of tries
-        int send_result = sendto(sock, packet, sizeof(RUDP_Packet), 0, (struct sockaddr *)&serverAddress, sizeof(serverAddress));
+        rudp_dump_headers("OUT", packet);
+        int send_result = sendto(sock, packet, sizeof(RUDP_Packet), 0, NULL, 0);
         if (send_result == -1)
         {
             perror("sendto failed");
@@ -89,8 +126,8 @@ int rudp_connect(int sock, const char *dest_ip, unsigned short int dest_port)
                 return -1;
             }
             memset(recv_packet, 0, sizeof(RUDP_Packet));
-            socklen_t serverAddrLen = sizeof(serverAddress);
-            int recv_result = recvfrom(sock, recv_packet, sizeof(RUDP_Packet), 0, (struct sockaddr *)&serverAddress, &serverAddrLen);
+            printf("%d: Waiting for RUDP socket [seq_num %d]\n", __LINE__, seq_num);
+            int recv_result = recvfrom(sock, recv_packet, sizeof(RUDP_Packet), 0, NULL, NULL);
             if (recv_result == -1)
             {
                 perror("recvfrom failed");
@@ -98,54 +135,32 @@ int rudp_connect(int sock, const char *dest_ip, unsigned short int dest_port)
                 free(packet);
                 return -1;
             }
+            rudp_dump_headers("IN ", recv_packet);
 
             if (recv_packet->flags.SYN && recv_packet->flags.ACK)
             {
                 free(recv_packet);
                 free(packet);
-                printf("Connected\n");
-                return 1;
-            }
-            else
-            {
-                printf("Received wrong packet when trying to connect\n");
+                printf("RUDP connected\n");
+                return 0;
             }
+            printf("Received wrong packet when trying to connect\n");
 
-            inner_total_tries ++;
-            if (inner_total_tries  == RETRY)
-            {
-                free(recv_packet);
-                free(packet);
-            }
+            inner_total_tries++;
+            free(recv_packet);
         }
         printf("Could not receive SYN-ACK packet\n");
         total_tries++;
     }
 
-    printf("Could not send SYN packet after %d retries\n", RETRY);
+    printf("Could not establish RUDP socket after %d retries\n", RETRY);
     free(packet); // free allocated memory
+
     return -1;
 }
 
-int rudp_accept(int sock, int port)
+int rudp_accept(int sock, int port, int *done)
 {
-    printf("Waiting for connection...\n");
-
-    // Setup the server address structure.
-    struct sockaddr_in serverAddress;
-    memset(&serverAddress, 0, sizeof(serverAddress));
-    serverAddress.sin_family = AF_INET;
-    serverAddress.sin_port = htons(port);
-    serverAddress.sin_addr.s_addr = htonl(INADDR_ANY);
-
-    // bind the socket to the server address
-    if (bind(sock, (struct sockaddr *)&serverAddress, sizeof(serverAddress)) == -1) 
-    {
-        perror("bind() failed");
-        close(sock);
-        return -1;
-    }
-
     // Setup the client address structure.
     struct sockaddr_in clientAddress; // client address
     memset(&clientAddress, 0, sizeof(clientAddress)); // zero out the structure
@@ -160,6 +175,7 @@ int rudp_accept(int sock, int port)
     }
     memset(packet, 0, sizeof(RUDP_Packet)); // zero out the packet
 
+    printf("%d: Waiting for RUDP socket\n", __LINE__);
     int recv_result = recvfrom(sock, packet, sizeof(RUDP_Packet), 0, (struct sockaddr *)&clientAddress, &clientAddressLength);
     if (recv_result == -1) 
     {
@@ -167,6 +183,14 @@ int rudp_accept(int sock, int port)
         free(packet);
         return -1;
     }
+    rudp_dump_headers("IN ", packet);
+
+    if (packet->all_flags == 0xFF)
+    {
+        *done = -1;
+        free(packet);
+        return 0;
+    }
 
     if (connect(sock, (struct sockaddr *)&clientAddress, clientAddressLength) == -1) 
     {
@@ -177,7 +201,6 @@ int rudp_accept(int sock, int port)
 
     if (packet->flags.SYN == 1) // if the received packet is a SYN packet
     {
-        printf("Received SYN\n");
         // send SYN-ACK message
         RUDP_Packet *syn_ack_packet = (RUDP_Packet *)malloc(sizeof(RUDP_Packet)); // allocate memory for the packet
         if (syn_ack_packet == NULL) 
@@ -189,7 +212,10 @@ int rudp_accept(int sock, int port)
         memset(syn_ack_packet, 0, sizeof(RUDP_Packet)); // zero out the packet
         syn_ack_packet->flags.SYN = 1; // set the SYN flag
         syn_ack_packet->flags.ACK = 1; // set the ACK flag
+        syn_ack_packet->seq_num = seq_num = packet->seq_num; // Initialize sequence number
+        syn_ack_packet->checksum = checksum(syn_ack_packet->data, syn_ack_packet->length);
 
+        rudp_dump_headers("OUT", syn_ack_packet);
         int send_result = sendto(sock, syn_ack_packet, sizeof(RUDP_Packet), 0, (struct sockaddr *)&clientAddress, clientAddressLength); // send the packet
         if (send_result == -1) // if the send failed
         {
@@ -199,21 +225,22 @@ int rudp_accept(int sock, int port)
             return -1;
         }
 
-        printf("Sent SYN-ACK\n");
         free(packet);
         free(syn_ack_packet);
-        return 1;
-    }
-    else
-    {
-        printf("Received wrong packet when trying to accept\n");
-        free(packet);
+
+        seq_num++;
+        printf("RUDP connected\n");
+        return 0;
     }
 
-    return 0;
+    printf("Received wrong packet when trying to accept\n");
+    free(packet);
+
+    return -1;
 }
 
-int rudp_recv(int sock, void *buffer, unsigned int buffer_size, pStrList *strList)
+
+int rudp_recv(int sock, void *buffer, unsigned int buffer_size, pStrList *strList, int *done)
 {
     RUDP_Packet *packet = (RUDP_Packet *)malloc(sizeof(RUDP_Packet));
     if (packet == NULL)
@@ -235,6 +262,7 @@ int rudp_recv(int sock, void *buffer, unsigned int buffer_size, pStrList *strLis
         return -1;
     }
 
+    printf("%d: Waiting for RUDP socket [seq_num %d]\n", __LINE__, seq_num);
     int recv_result = recvfrom(sock, packet, sizeof(RUDP_Packet), 0, NULL, NULL);
     if (recv_result == -1)
     {
@@ -242,111 +270,59 @@ int rudp_recv(int sock, void *buffer, unsigned int buffer_size, pStrList *strLis
         free(packet);
         return -1;
     }
+    rudp_dump_headers("IN ", packet);
 
     // Check if the packet is corrupted
-    if (checksum(packet->data, sizeof(packet->data)) != packet->checksum)
-    {
-        free(packet);
-        return -1;
-    }
-
-    // Send ACK for the received packet
-    if (send_ack(sock, packet) == 0)
+    if (checksum(packet->data, packet->length) != packet->checksum)
     {
+        printf("checksum error: 0x%08X 08%08X\n", checksum(packet->data, packet->length), packet->checksum);
         free(packet);
-        return -1;
+        return 0;
     }
 
     // Check if the packet is a SYN packet
-    if (packet->flags.SYN == 1)
+    if (packet->flags.SYN)
     {
+        seq_num = 0; // Initialize sequence number
         free(packet);
-        printf("Received SYN\n");
         return 0;
     }
 
-    int sq_num = 0; // Initialize sequence number
-
-    if (packet->seq_num == sq_num)
+    if (packet->seq_num != seq_num)
     {
-        int result = receive_data_packet(sock, buffer, packet, &sq_num);
         free(packet);
-        return result;
-    }
-    else if (packet->flags.DATA == 1)
-    {
-        free(packet);
-        return 0;
+        return -1;
     }
 
-    if (packet->flags.FIN == 1)
+    // Send ACK for the received packet
+    if (send_ack(sock, packet) < 0)
     {
-        printf("Received close request\n");
-        int result = handle_fin_packet(sock, packet);
         free(packet);
-        return result;
-    }
-
-    free(packet);
-    return 0;
-}
-
-int receive_data_packet(int sock, void *buffer, RUDP_Packet *packet, int *sq_num)
-{
-    if (packet->flags.FIN == 1 && packet->flags.DATA == 1)
-    { // last packet
-        memcpy(buffer, packet->data, packet->length);
-        (*sq_num)++;
-        return 1;
+        return -1;
     }
 
-    if (packet->flags.DATA == 1)
-    { // data packet
-        memcpy(buffer, packet->data, packet->length);
-        (*sq_num)++;
-        return 1;
+    if (packet->flags.FIN)
+    {
+        *done = 1;
     }
 
-    return 0;
-}
-
-int handle_fin_packet(int sock, RUDP_Packet *packet)
-{
-    // close request
-    // send ACK and wait for TIMEOUT*10 seconds to check if the sender closed
-    printf("Received close request\n");
-    set_timeout(sock, TIMEOUT * 10);
-
-    time_t FIN_send_time = time(NULL);
-    printf("Waiting for close\n");
-
-    while ((double)(time(NULL) - FIN_send_time) < TIMEOUT)
+    if (packet->flags.DATA)
     {
-        memset(packet, 0, sizeof(RUDP_Packet));
-        int recv_result = recvfrom(sock, packet, sizeof(RUDP_Packet) - 1, 0, NULL, 0);
-        if (recv_result == -1)
-        {
-            perror("recvfrom failed");
-            return -1;
-        }
+        int len = packet->length;
+        memcpy(buffer, packet->data, len);
+        free(packet);
 
-        if (packet->flags.FIN == 1)
-        {
-            if (send_ack(sock, packet) == -1)
-            {
-                return -1;
-            }
-            FIN_send_time = time(NULL);
-        }
+        seq_num++;
+        return len;
     }
 
-    close(sock);
-    return -2;
+    free(packet);
+    return 0;
 }
 
 int rudp_send(int sock, void *buffer, unsigned int buffer_size)
 {
-    int id_packet = 0; // id of the packet
+    // number of packets to send.  Last data packet must be partial, even if buffer_size==MSG_BUFFER_SIZE.
     int packet_amount = buffer_size / MSG_BUFFER_SIZE + (buffer_size % MSG_BUFFER_SIZE != 0); // number of packets to send
 
     RUDP_Packet *recv_packet = malloc(sizeof(RUDP_Packet)); // allocate memory for the received packet
@@ -368,25 +344,32 @@ int rudp_send(int sock, void *buffer, unsigned int buffer_size)
 
         memset(packet, 0, sizeof(RUDP_Packet)); // zero out the packet
         packet->flags.DATA = 1; // set the DATA flag
-        packet->seq_num = id_packet; // set the sequence number
+        packet->seq_num = ++seq_num; // set the sequence number
 
         // Set the FIN flag for the last packet
         if (i == packet_amount - 1)
         {
             packet->flags.FIN = 1;
+            // set the length of the packet
+            packet->length = buffer_size;
+        }
+        else
+        {
+            // set the length of the packet
+            packet->length = MSG_BUFFER_SIZE;
+            buffer_size -= packet->length;
         }
-
-        packet->length = (i == packet_amount - 1) ? buffer_size % MSG_BUFFER_SIZE : MSG_BUFFER_SIZE; // set the length of the packet
 
         memcpy(packet->data, buffer + i * MSG_BUFFER_SIZE, packet->length); // copy the data to the packet
 
         // Calculate the checksum for the packet
-        packet->checksum = checksum(packet->data, sizeof(packet->data));
+        packet->checksum = checksum(packet->data, packet->length);
 
         int total_tries = 0; // total number of tries
         while (total_tries < RETRY) // while the total number of tries is less than the maximum number of tries
         {
-            ssize_t send_result = sendto(sock, packet, sizeof(RUDP_Packet), 0, NULL, 0); // send the packet
+            rudp_dump_headers("OUT", packet);
+            ssize_t send_result = sendto(sock, packet, offsetof(RUDP_Packet, data) + packet->length, 0, NULL, 0); // send the packet
             if (send_result == -1) // if the send failed
             {
                 perror("sendto failed");
@@ -400,6 +383,7 @@ int rudp_send(int sock, void *buffer, unsigned int buffer_size)
             do
             {
                 // receive ACK message
+                printf("%d: Waiting for RUDP socket [seq_num %d]\n", __LINE__, seq_num);
                 ssize_t recv_result = recvfrom(sock, recv_packet, sizeof(RUDP_Packet), 0, NULL, 0); // receive the packet
                 if (recv_result == -1) // if the receive failed
                 {
@@ -408,9 +392,15 @@ int rudp_send(int sock, void *buffer, unsigned int buffer_size)
                     free(recv_packet);
                     return -1;
                 }
+                rudp_dump_headers("IN ", recv_packet);
 
-                if (recv_packet->flags.ACK && recv_packet->seq_num == id_packet) // if the received packet is an ACK packet
+                if (recv_packet->flags.ACK && recv_packet->seq_num == seq_num) // if the received packet is an ACK packet
                 {
+                    if (recv_packet->flags.FIN)
+                    {
+                        printf("RUDP disconnected\n");
+                    }
+                    total_tries = RETRY;   // no need to retry
                     break; // break the loop
                 }
             } while ((double)(clock() - start_time) / CLOCKS_PER_SEC < TIMEOUT); // while the time elapsed is less than the timeout
@@ -420,12 +410,11 @@ int rudp_send(int sock, void *buffer, unsigned int buffer_size)
 
         if (total_tries == RETRY) // if the total number of tries is equal to the maximum number of tries
         {
-            printf("Could not send packet %d\n", id_packet); // print an error message
+            printf("Could not send packet %d\n", seq_num); // print an error message;
             free(packet); // free the packet
             return -1; // return an error
         }
 
-        id_packet++; // increment the id of the packet
         free(packet); // free the packet
     }
 
@@ -433,21 +422,20 @@ int rudp_send(int sock, void *buffer, unsigned int buffer_size)
     return 1; // return success
 }
 
-int rudp_close(int sock)
+int rudp_close(int sock, int send)
 {
-    RUDP_Packet *close_pk = (RUDP_Packet *)malloc(sizeof(RUDP_Packet));
-    if (close_pk == NULL)
+    if (send)
     {
-        perror("malloc failed");
-        return -1;
-    }
-    memset(close_pk, 0, sizeof(RUDP_Packet));
-    close_pk->flags.FIN = 1;
-    close_pk->seq_num = -1;
-    close_pk->checksum = checksum(close_pk->data, sizeof(close_pk->data));
+        RUDP_Packet *close_pk = (RUDP_Packet *)malloc(sizeof(RUDP_Packet));
+        if (close_pk == NULL)
+        {
+            perror("malloc failed");
+            return -1;
+        }
+        memset(close_pk, 0, sizeof(RUDP_Packet));
+        close_pk->all_flags = 0xFF;   // special case to signal RUDP connection ended
 
-    do
-    {
+        rudp_dump_headers("OUT", close_pk);
         int sendResult = sendto(sock, close_pk, sizeof(RUDP_Packet), 0, NULL, 0);
         if (sendResult == -1)
         {
@@ -455,16 +443,13 @@ int rudp_close(int sock)
             free(close_pk);
             return -1;
         }
-    } while (wait_for_ack(sock, -1, clock(), TIMEOUT) == -1);
-
-    if (close(sock) == -1)
-    {
         free(close_pk);
-        perror("close failed");
-        return -1;
     }
-    free(close_pk);
-    return 0;  // or return 1; depending on your convention
+
+    close(sock);
+
+    printf("UDP socket closed\n");
+    return 0;
 }
 
 
@@ -480,7 +465,7 @@ unsigned short int checksum(void *data, unsigned int bytes)
     }
     // Add left-over byte, if any
     if (bytes > 0)
-    total_sum += *((unsigned char *)data_pointer);
+        total_sum += *((unsigned char *)data_pointer);
     // Fold 32-bit sum to 16 bits
     while (total_sum >> 16)
         total_sum = (total_sum & 0xFFFF) + (total_sum >> 16);
@@ -494,63 +479,32 @@ int send_ack(int socket, RUDP_Packet *packet)
     if (ack_packet == NULL) 
     {
         perror("malloc failed");
-        return 0;
+        return -1;
     }
     memset(ack_packet, 0, sizeof(RUDP_Packet));
 
     ack_packet->flags.ACK = 1;
     ack_packet->flags.FIN = packet->flags.FIN;
     ack_packet->flags.SYN = packet->flags.SYN;
-    ack_packet->flags.DATA = packet->flags.DATA;
-
     ack_packet->seq_num = packet->seq_num;
+    ack_packet->checksum = checksum(ack_packet->data, ack_packet->length);
 
-    // Update the checksum calculation based on your actual data
-    ack_packet->checksum = checksum(ack_packet->data, sizeof(ack_packet->data));
-
-    int sendResult = sendto(socket, &ack_packet, sizeof(RUDP_Packet), 0, NULL, 0);
-
-    if (sendResult == -1) 
+    rudp_dump_headers("OUT", ack_packet);
+    if (sendto(socket, ack_packet, sizeof(RUDP_Packet), 0, NULL, 0) == -1)
     {
-        printf("sendto failed\n");
+        perror("sendto failed");
         free(ack_packet);
-        return 0;
+        return -1;
     }
-    free(ack_packet);
-    return 1;
-}
-
-int wait_for_ack(int socket, int seq_num, clock_t start_time, int timeout) 
-{
-    RUDP_Packet *packetReply = malloc(sizeof(RUDP_Packet));
-
-    // Calculate the expiration time (start_time + timeout seconds)
-    clock_t expiration_time = start_time + timeout * CLOCKS_PER_SEC;
-
-    while (clock() < expiration_time) 
+    if (ack_packet->flags.FIN)
     {
-        int recvLen = recvfrom(socket, packetReply, sizeof(RUDP_Packet) - 1, 0, NULL, 0);
-        if (recvLen == -1) 
-        {
-            free(packetReply);
-            return -1;
-        }
-
-        if (packetReply->seq_num == seq_num && packetReply->flags.ACK == 1) 
-        {
-            free(packetReply);
-            return 1;
-        }
+        printf("RUDP disconnected\n");
     }
-    free(packetReply);
-    return -1;
+    free(ack_packet);
+    return 0;
 }
 
-
-
-
 // ************ Linked List **************
-
 Node *Node_alloc(int run, double time, double speed, Node *next)
 {
     Node *p = (Node *)malloc(sizeof(Node));
@@ -645,4 +599,4 @@ void print_stats(const StrList *strList)
     printf("Average Time: %f ms\n", totalTime / strList->_size);
     printf("Average Speed: %f MB/s\n", totalSpeed / strList->_size);
     printf("-----------------------------\n");
-}
\ No newline at end of file
+}
diff --git a/RUDP_API.h b/RUDP_API.h
index 40b2354..7ccd82a 100644
--- a/RUDP_API.h
+++ b/RUDP_API.h
@@ -11,37 +11,28 @@
 #define MSG_BUFFER_SIZE 16384
 #define FILE_SIZE (1024 * 1024 * 2)
 #define RETRY 3
-#define TIMEOUT 5
+#define TIMEOUT 30
 
 typedef struct _RUDP_Flags 
 {
-    unsigned int SYN : 1;
-    unsigned int ACK : 1;
-    unsigned int DATA : 1;
-    unsigned int FIN : 1;
+    unsigned char SYN : 1;
+    unsigned char ACK : 1;
+    unsigned char DATA : 1;
+    unsigned char FIN : 1;
 } RUDP_flags;
 
 typedef struct _RUDP_Packet 
 {
-    RUDP_flags flags;
-    unsigned int length;
-    unsigned int checksum;
-    unsigned int seq_num;
+    union {
+        RUDP_flags flags;
+        unsigned char all_flags;
+    };
+    unsigned short int length;
+    unsigned short int checksum;
+    unsigned short int seq_num;
     char data[MSG_BUFFER_SIZE];
 } RUDP_Packet;
 
-int rudp_socket();
-int rudp_connect(int sock, const char *dest_ip, unsigned short int dest_port);
-int rudp_accept(int sock, int port);
-int rudp_recv(int sock, void *buffer, unsigned int buffer_size, pStrList *strList);
-int rudp_send(int sock, void *buffer, unsigned int buffer_size);
-int rudp_close(int sock);
-int receive_data_packet(int sock, void *buffer, RUDP_Packet *packet, int *sq_num);
-int wait_for_ack(int socket, int seq_num, clock_t start_time, int timeout);
-int handle_fin_packet(int sock, RUDP_Packet *packet);
-int send_ack(int socket, RUDP_Packet *packet);
-unsigned short int checksum(void *data, unsigned int bytes);
-
 //******************* linked list ****************
 typedef struct _Node
 {
@@ -57,6 +48,19 @@ typedef struct _StrList
     size_t _size;
 } StrList, *pStrList;
 
+/* Opens the socket. Sender: connect; Reciever: bind. */
+int udp_socket(const char *dest_ip, unsigned short int dest_port);
+/* Sender: sends SYN, waits for SYN+ACK */
+int rudp_socket(int sock);
+/* Reciever: connect + gets SYN+ACK or flags=0xFF for USP termination */
+int rudp_accept(int sock, int port, int *done);
+int rudp_recv(int sock, void *buffer, unsigned int buffer_size, pStrList *strList, int *done);
+int rudp_send(int sock, void *buffer, unsigned int buffer_size);
+int rudp_close(int sock, int send);
+int receive_data_packet(int sock, void *buffer, RUDP_Packet *packet, int *sq_num);
+int send_ack(int socket, RUDP_Packet *packet);
+unsigned short int checksum(void *data, unsigned int bytes);
+
 void print_stats(const StrList *strList);
 void StrList_insertLast(StrList *strList, int run, double time, double speed);
 size_t StrList_size(const StrList *strList);
diff --git a/RUDP_Receiver.c b/RUDP_Receiver.c
index f99b682..4f6b4bf 100644
--- a/RUDP_Receiver.c
+++ b/RUDP_Receiver.c
@@ -15,33 +15,34 @@ int main(int argc, char* argv[])
     }
 
     int port = atoi(argv[2]);
-    StrList* strList = StrList_alloc();
 
-    printf("RUDP Receiver\n");
+    printf("Starting RUDP Receiver\n\n");
 
     // Create a UDP socket
-    int sock = rudp_socket();
+    int sock = udp_socket(NULL, port);
     if (sock == -1)
     {
-        perror("Failed to create socket");
         return 1;
     }
-    printf("Socket created\n");
 
-    // Accept incoming connection requests
-    if (rudp_accept(sock,port) == 0)
-    {
-        perror("Failed to accept connection");
-        rudp_close(sock);
-        return 1;
-    }
-    printf("Connection accepted\n");
 
     char buffer[MSG_BUFFER_SIZE];
     int round = 1;
+    int done, bytes_received, totalBytes;
+    StrList* strList = StrList_alloc();
 
     do
     {
+        done = 0;
+
+        // Accept incoming connection requests
+        if (rudp_accept(sock, port, &done) < 0)
+        {
+            perror("Failed to accept connection");
+            rudp_close(sock, 0);
+            return 1;
+        }
+
         // Clear the buffer
         memset(buffer, 0, sizeof(buffer));
 
@@ -49,70 +50,41 @@ int main(int argc, char* argv[])
         clock_t start_time, end_time;
         
         // Receive data from the client in chunks
-        int bytes_received;
         int firstround = 1;
-        int totalBytes = 0;
 
-        while ((bytes_received = rudp_recv(sock, buffer, sizeof(buffer), &strList)) > 0)
+        while ((done == 0) && ((bytes_received = rudp_recv(sock, buffer, sizeof(buffer), &strList, &done)) >= 0))
         {
             if (firstround)
             {
+                firstround = 0;
+                totalBytes = 0;
                 start_time = clock();
-                printf("Start receiving data\n");
             }
-
-            if ((strstr(buffer, "Finish\n") != NULL) || (strstr(buffer, "Exit\n") != NULL))
-            {
-                printf("Received finish command. Exiting loop.\n");
-                break;
-            }
-
-            // Handle received data
-            if (bytes_received < 0)
-            {
-                perror("rudp_recv()");
-                close(sock);
-                StrList_free(strList);
-                return 1;
-            }
-            else if (bytes_received == 0)
-            {
-                fprintf(stdout, "Client disconnected\n");
-                close(sock);
-                break;
-            }
-            else
-            {
-                // Ensure that the buffer is null-terminated
-                if (buffer[MSG_BUFFER_SIZE - 1] != '\0')
-                    buffer[MSG_BUFFER_SIZE - 1] = '\0';
-            }
-
-            firstround = 0;
             totalBytes += bytes_received;
-            printf("Received %d bytes\n", bytes_received); // Add this line for debugging
-            bzero(buffer, MSG_BUFFER_SIZE); // needed?
+            printf("Got %d bytes of data.  Total %d bytes\n", bytes_received, totalBytes);
         }
 
-        // Capture end time
-        end_time = clock();
-        printf("End receiving data\n");
-        printf("Total bytes received: %d\n", totalBytes);
+        if (done > 0) {
+            // Capture end time
+            end_time = clock();
+            printf("End receiving data\n");
 
-        // Calculate time difference in milliseconds
-        double milliseconds = ((double)(end_time - start_time) / CLOCKS_PER_SEC) * 1000.0;
+            // Calculate time difference in milliseconds
+            double milliseconds = ((double)(end_time - start_time) / CLOCKS_PER_SEC) * 1000.0;
+            StrList_insertLast(strList, round, milliseconds, totalBytes / milliseconds);
+            printf("Run #%d Data: Time: %fms Speed: %fMB/s\n\n", round, milliseconds, totalBytes / milliseconds);
+            round++;
+        }
+    } while (done > 0);
 
-        StrList_insertLast(strList, round, milliseconds, totalBytes / milliseconds);
-        fprintf(stdout, "Run #%d Data: Time: %fms Speed: %fMB/s\n", round, milliseconds, totalBytes / milliseconds);
-        round++;
-    } while (strstr(buffer, "Exit\n") == NULL);
+    rudp_close(sock, 0);
 
     // Print statistics
     print_stats(strList);
 
     StrList_free(strList);
 
-    rudp_close(sock);
+    printf("\nReceiver finished!\n");
 
     return 0;
-}
\ No newline at end of file
+}
diff --git a/RUDP_Sender.c b/RUDP_Sender.c
index b265889..53aec4e 100644
--- a/RUDP_Sender.c
+++ b/RUDP_Sender.c
@@ -40,60 +40,55 @@ int main(int argc, char *argv[])
 
     char buffer[MSG_BUFFER_SIZE] = {0};
 
+    printf("Starting RUDP Sender\n\n");
+
     // Generate some random data.
     unsigned int size = FILE_SIZE;
     char *message = util_generate_random_data(size);
     if (message == NULL)
     {
         perror("util_generate_random_data() failed");
-        return -1;
+        return 1;
     }
     printf("Generated %d bytes of random data\n", size);
 
     // Try to create a UDP socket (IPv4, datagram-based, default protocol).
-    int sock = rudp_socket();
+    int sock = udp_socket(argv[2], atoi(argv[4]));
     if (sock == -1)
     {
-        perror("rudp_socket() failed");
-        return 1;
-    }
-    printf("Created an RUDP socket\n");
-
-    if (rudp_connect(sock, argv[2], atoi(argv[4])) <= 0)
-    {
-        perror("rudp_connect() failed");
-        rudp_close(sock);
-        free(message);
+        perror("udp_socket() failed");
         return 1;
     }
-    printf("Connected to server at %s:%s\n", argv[2], argv[4]);
 
     char again = 'y';
     while (again == 'y')
     {
+        // Create RUDP socket
+        if (rudp_socket(sock) < 0) {
+            close(sock);
+            return 1;
+        }
+
         // Send the data.
-        int total_bytes_sent = 0;
-        int remaining_bytes = size;
         if (rudp_send(sock, message, size) <= 0)
         {
-            perror("rudp_send() failed");
-            rudp_close(sock);
-            free(message);
+            printf("Could not send RUDP message\n");
+            close(sock);
             return 1;
         }
-        printf("Sent %d bytes to the server!\n", total_bytes_sent);
+
+        printf("Sent %d bytes to the server!\n\n", size);
         printf("Do you want to send the message again? (y/n): ");
         scanf(" %c", &again);
-        // Reset total_bytes_sent and remaining_bytes for the next iteration
-        total_bytes_sent = 0;
-        remaining_bytes = size;
     }
+    free(message);
 
-    // The loop completed successfully, and all bytes were sent.
-    fprintf(stdout, "Client finished!\n");
     // Close the socket UDP socket.
-    rudp_close(sock);
-    printf("Closed the RUDP socket\n");
-    free(message);
+    if (rudp_close(sock, 1) < 0) {
+        close(sock);
+        return 1;
+    }
+
+    printf("\nClient finished!\n");
     return 0;
 }
